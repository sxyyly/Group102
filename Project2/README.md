第二原像攻击：即给定消息M1时，攻击者能够找到另一条消息M2,其哈希值与M1的哈希值相同。理论上复杂度为O(2n)
Hash函数的ρ方法是用来寻找散列碰撞而不需要大量的内存。它的想法是不断地对前一个哈希运算的结果进行哈希运算。
当我们对一个起始值进行散列，然后对该散列进行散列，并重复这个过程，不会永远得到不同的数字。
最终我们会得到一个重复的值，之后所有进一步的值都是之前值的重复，在一个循环中进行，如下图所示。


Rho攻击流程：
1)给定具有n比特哈希值的哈希函数，选择一些随机哈希值H1,设H1'=H1
2)计算H2=Hash(H1),H2'=Hash(Hash(H1'))
3)迭代该过程并计算Hi+1=Hash(Hi)，Hi+1'=Hash(Hash(Hi'))，直到有一个i可以满足Hi+1=Hi+1'
更进一步的寻找碰撞的技术的工作原理是：
首先检测循环的开始，然后查找碰撞。既不需要在内存中存储大量的值，也不需要对长的列表进行排序。
ρ方法大约需要2n/2次操作才能成功。
平均来说，循环和尾部（图中从H1延伸到H5的部分）各包括约2n/2个哈希值，其中n是哈希值的长度
因此，我们需要至少2n/2+ 2n/2次计算来发现一个碰撞。

实现方式：
(1)函数rho_method接受一个参数exm，表示需要生成的16进制位数。将exm除以4得到位数的数量（每个十六进制位表示4位二进制数）。
(2)生成一个随机的十六进制数x，位数为exm，并计算其哈希值作为初始值x_a。将初始值x_a进行一次哈希运算，得到新的值x_b。
(3) 使用循环进行以下步骤，直到满足终止条件：检查x_a和x_b的前num位是否相等。
(4) 在每一轮中，将x_a更新为其哈希值，并将x_b更新为经过两次哈希运算的结果。
(5) 循环结束后，将x_b的值赋给x_a，即x_a = x_b。将x_a的哈希值和原始的十六进制值x_a、x_b作为结果返回。如果在循环中没有找到满足条件的结果，则返回None或者适当的错误处理。

运行速度：2.345s
实验环境
CPU型号：基准速度:3.20 GHz
插槽：1
内核：1
虚拟化：已启用
逻辑处理器：16
L1缓存：512KB
L2缓存：4.0MB
L3缓存：16.0MB